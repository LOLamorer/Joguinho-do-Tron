import glfw
import math
from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *

x1_posicao = -0.5
y1_posicao = 0.0
x2_posicao = 0.5
y2_posicao = 0.0
window = None

keys_pressed = set()  # Armazena as teclas pressionadas

# Listas para armazenar os rastros das motos
rastro_moto1 = []
rastro_moto2 = []


def key_callback(window, key, scancode, action, mods):
    global keys_pressed
    if action == glfw.PRESS:
        keys_pressed.add(key)  # Adiciona a tecla pressionada ao conjunto
    elif action == glfw.RELEASE:
        if key in keys_pressed:
            keys_pressed.remove(key)  # Remove a tecla liberada do conjunto


def update_positions():
    global x1_posicao, y1_posicao, x2_posicao, y2_posicao
    step_size = 0.03  # Reduzindo a velocidade

    for key in keys_pressed:
        if key == glfw.KEY_UP:
            y2_posicao += step_size
        elif key == glfw.KEY_DOWN:
            y2_posicao -= step_size
        elif key == glfw.KEY_LEFT:
            x2_posicao -= step_size
        elif key == glfw.KEY_RIGHT:
            x2_posicao += step_size
        elif key == glfw.KEY_W:
            y1_posicao += step_size
        elif key == glfw.KEY_S:
            y1_posicao -= step_size
        elif key == glfw.KEY_A:
            x1_posicao -= step_size
        elif key == glfw.KEY_D:
            x1_posicao += step_size

    # Adiciona a posição atual à lista de rastros
    rastro_moto1.append((x1_posicao, y1_posicao))
    rastro_moto2.append((x2_posicao, y2_posicao))


def draw_moto(x, y, color):
    glColor3f(*color)
    glBegin(GL_TRIANGLES)
    glVertex2f(x - 0.05, y - 0.05)
    glVertex2f(x + 0.05, y - 0.05)
    glVertex2f(x - 0.05, y + 0.05)
    glEnd()
    glColor3f(0.0, 0.0, 0.0)

    glBegin(GL_POLYGON)
    for i in range(360):
        angle = i * math.pi / 180
        x_wheel = x - 0.05 + 0.08 * math.cos(angle)
        y_wheel = y - 0.05 + 0.08 * math.sin(angle)
        glVertex2f(x_wheel, y_wheel)
    glEnd()

    glBegin(GL_POLYGON)
    for i in range(360):
        angle = i * math.pi / 180
        x_wheel = x + 0.05 + 0.08 * math.cos(angle)
        y_wheel = y - 0.05 + 0.08 * math.sin(angle)
        glVertex2f(x_wheel, y_wheel)
    glEnd()


def draw_rastro(rastro):
    glColor3f(0.8, 0.8, 0.8)
    glBegin(GL_LINE_STRIP)
    for posicao in rastro:
        glVertex2f(posicao[0], posicao[1])
    glEnd()


def draw_track():
    glColor3f(0.3, 0.3, 0.3)
    glBegin(GL_QUADS)
    glVertex2f(-1.0, -0.3)
    glVertex2f(1.0, -0.3)
    glVertex2f(1.0, -1.0)
    glVertex2f(-1.0, -1.0)
    glEnd()

    glColor3f(0.3, 0.3, 0.3)
    glBegin(GL_QUADS)
    glVertex2f(-1.0, -0.3)
    glVertex2f(-0.8, -0.3)
    glVertex2f(-0.8, -0.5)
    glVertex2f(-1.0, -0.5)
    glEnd()

    glBegin(GL_QUADS)
    glVertex2f(0.8, -0.3)
    glVertex2f(1.0, -0.3)
    glVertex2f(1.0, -0.5)
    glVertex2f(0.8, -0.5)
    glEnd()

    glLineWidth(3.0)
    glColor3f(1.0, 1.0, 1.0)
    glBegin(GL_LINES)
    glVertex2f(-1.0, -1.0)
    glVertex2f(1.0, -1.0)
    glEnd()
    glLineWidth(1.0)


def draw():
    glClear(GL_COLOR_BUFFER_BIT)
    glClearColor(0.5, 0.5, 0.5, 1.0)
    glLoadIdentity()
    draw_track()
    draw_rastro(rastro_moto1)
    draw_rastro(rastro_moto2)
    draw_moto(x1_posicao, y1_posicao, (1.0, 0.0, 0.0))
    draw_moto(x2_posicao, y2_posicao, (0.0, 0.0, 1.0))
    glfw.swap_buffers(window)


def main():
    global window
    if not glfw.init():
        return

    window = glfw.create_window(800, 600, "Teclado", None, None)
    if not window:
        glfw.terminate()
        return

    glfw.make_context_current(window)
    glfw.set_key_callback(window, key_callback)

    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluOrtho2D(-1, 1, -1, 1)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    while not glfw.window_should_close(window):
        glfw.poll_events()
        update_positions()  # Atualiza as posições das motos
        draw()

    glfw.terminate()


if __name__ == "__main__":
    main()
